//
// Created by Rishabh Mittal on 04/20/2018
//
#pragma once

#include <memory>
#include <functional>

namespace iomgr {

struct ioMgr;
struct IOManager;
struct fd_info;
using ev_callback = std::function< void(int fd, void* cookie, uint32_t events) >;

class EndPoint {
protected:
public:
    explicit EndPoint() {}
    virtual ~EndPoint() = default;

    virtual void init_local() = 0;
};

enum iomgr_msg_type {
    RESCHEDULE = 1,         // Reschedule the IO polling to your thread
    WAKEUP,                 // Wakeup and start doing some io
    SHUTDOWN,               // Shutdown this thread
    DESIGNATE_IO_THREAD,    // Designate this thread as io thread
    RELINQUISH_IO_THREAD,   // Unmark yourself from io thread and exit io loop
    CUSTOM_MSG,             // Custom message specific to appln
};

struct iomgr_msg {
    iomgr_msg_type m_type;
    fd_info*       m_fd_info;   // fd which this message pertaining to. Can be null
    int            m_event;     // EPOLL event if any to be notified to the callback
    void*          m_data_buf;  // Message data buffer and its size
    uint32_t       m_data_size;

    iomgr_msg() : iomgr_msg(WAKEUP, nullptr, EPOLLIN, nullptr, 0) {}

    iomgr_msg(const iomgr_msg& msg) {
        operator=(msg);
    }

    iomgr_msg& operator=(const iomgr_msg& msg) = default;

    iomgr_msg(iomgr_msg_type type, fd_info* info, int event, void *buf = nullptr, uint32_t size = 0) :
            m_type(type), m_fd_info(info), m_event(event), m_data_buf(buf), m_data_size(size) {}
};

struct ioMgr {
    ioMgr(size_t const num_ep, size_t const num_threads);
    ~ioMgr();

    void     start();
    void     run_io_loop();
    void     add_ep(EndPoint* ep);
    fd_info* add_fd(EndPoint* ep, int const fd, ev_callback cb, int const ev, int const pri, void* cookie);
    fd_info* add_per_thread_fd(EndPoint* ep, int const fd, ev_callback cb, int const ev, int const pri, void* cookie);

    void fd_reschedule(int const fd, uint32_t const event);
    void fd_reschedule(fd_info* info, uint32_t const event);

    void process_done(int const fd, int const ev);
    void process_done(fd_info* info, int const ev);

    void print_perf_cntrs();

private:
    std::unique_ptr< IOManager > _impl;
};

} // namespace iomgr
